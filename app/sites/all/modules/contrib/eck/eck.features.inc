<?php

/**
 * @{
 * ECK Entity Types
 */

/**
 * Implementation of hook_features_export_options().
 */
function eck_entity_type_features_export_options() {
  module_load_include('inc', 'eck', 'eck.entity_type');
  $entity_types = array();
  foreach (EntityType::loadAll() as $entity_type) {
    // @TODO: Ideally, this module should allow us to access ALL entity types,
    // but, we currently only want to check on types created through ECK.
    // +1 on ECK taking over all entity types :)
    $entity_types[$entity_type->name] = $entity_type->label;
  }
  return $entity_types;
}



/**
 * Implementation of hook_features_export.
 */
function eck_entity_type_features_export($data, &$export, $module_name = '') {
  $pipe = array();

  foreach ($data as $entity_type) {
    // Export the entity type
    $export['features']['eck_entity_type'][$entity_type] = $entity_type;
    $export['dependencies']['eck_entity_type'] = 'eck';
    //@TODO we need to add dependencies on the modules implementing the property behaviors
    //currently they are all implemented by ECK but in the future, people might have their custom 
    //behaviors.. or we might have behaviors provided by contrib.
    $export['dependencies']['features'] = 'features';
  }

  return $pipe;
}



/**
 * Implementation of hook_features_export_render().
 */
function eck_entity_type_features_export_render($module, $data, $export = NULL) {
  //I am guessing that using FALSE and TRUE to initialize the array is arbritrary, rigth?
  $elements = array(
    'name' => FALSE,
    'label' => TRUE,
    'properties' => FALSE,
  );

  $output = array();
  $output[] = '$items = array(';

  foreach ($data as $entity_type_name) {
    //This data is being generated by ECK, so no need to export it
    //$entity_metadata = entity_metadata_wrapper($entity_type_name);
    $entity_type = EntityType::loadByName($entity_type_name);
    
    $elements['name'] = $entity_type->name;
    $elements['label'] = $entity_type->label;
    $elements['properties'] = $entity_type->properties;
    $output[] = '       ' . "'{$entity_type->name}' => " . features_var_export($elements).",";
  }

  $output[] = '  );';
  $output[] = '  return $items;';

  return array('eck_entity_type_info' => implode("\n", $output));
}

/**
 * Implementation of hook_features_revert().
 */
function eck_entity_type_features_revert($module) {
  eck_entity_type_features_rebuild($module);
}

/**
 * Implements of hook_features_rebuild().
 *
 * Rebuilds eck entities from code defaults.
 */
function eck_entity_type_features_rebuild($module) {
 
  if ($default_entities = features_get_default('eck_entity_type', $module)) {
    foreach ($default_entities as $entity_type_name => $entity_type_info) {
      
      //dpm($entity_type_info, $entity_type_name);
      
      $entity_type = new EntityType();
      foreach($entity_type_info as $key => $value){
        $entity_type->{$key} = $value; 
      }
      
      $entity_type->save();
    }

    drupal_get_schema(NULL, TRUE);
    entity_info_cache_clear();
    menu_rebuild();
  }
}

/**
 * @} End of ECK Entity Types.
 */

/**
 * @{
 * ECK Bundles
 */

/**
 * Implementation of hook_features_export_options().
 */
function eck_bundle_features_export_options() {
  $bundles = array();
  foreach (Bundle::loadAll() as $bundle) {
    // @TODO: Ideally, all bundles should be accessible to features, but
    // we're currently just targeting those created through ECK.
      $entity_type = EntityType::loadByName($bundle->entity_type);
      $bundles[$bundle->machine_name] = "{$entity_type->label}:{$bundle->label}";
  }
  return $bundles;
}



/**
 * Implementation of hook_features_export.
 */
function eck_bundle_features_export($data, &$export, $module_name = '') {
  $pipe = array();
  //what is this for?
  $map = features_get_default_map('eck');

  foreach ($data as $type) {
    //This was probably copied from node features code, I don't believe we need this dependency check
    /*// If this entity type is provided by a different module, add it as a dependency.
    if (isset($map[$entity_name]) && $map[$entity_name] != $module_name) {
      $export['dependencies'][$map[$entity_name]] = $map[$entity_name];
    }
    else {
      // Add a dependency on the ECK entity.
      $pipe['eck'][] = $entity_name;
    }*/

    // Export the entity type.
    $export['features']['eck_bundle'][$type] = $type;
    $export['dependencies']['eck'] = 'eck';
    $export['dependencies']['features'] = 'features';

    // Export fields.
    // @TODO: Features already supports this, just gotta find the right calls.
    $bundle = Bundle::loadByMachineName($type);
    $fields = field_info_instances($bundle->entity_type, $bundle->name);
    foreach ($fields as $field) {
      $pipe['field'][] = "{$bundle->entity_type}-{$field['bundle']}-{$field['field_name']}";
    }
  }

  return $pipe;
}

/**
 * Implementation of hook_features_export_render().
 */
function eck_bundle_features_export_render($module, $data, $export = NULL) {
  $elements = array(
    'machine_name' => NULL,
    'entity_type' => NULL,
    'name' => NULL,
    'label' => NULL,
  );
  $output =  array();
  $output[] = '  $items = array(';
  
  foreach($data as $bundle_machine_name){
    $bundle = Bundle::loadByMachineName($bundle_machine_name);
    unset($bundle->id);
    
    foreach($elements as $key => $value){
      $elements[$key] = $bundle->{$key};
    }
    
    // @TODO: Can entities exist without bundles?
    // Yes they can, but in ECK (as it is right now) all entities start with a bundle
    //I believe you can delete all the bundles from an entity type and everything would still
    //work, but I have not tried it.
    
    $output[] = "  '{$bundle->machine_name}' => ". features_var_export($elements) .",";
  }
  
  $output[] = '  );';

  
  $output[] = '  return $items;';

   return array('eck_bundle_info' => implode("\n", $output));
}



/**
 * Implementation of hook_features_revert().
 */
function eck_bundle_features_revert($module) {
  eck_bundle_features_rebuild($module);
}



/**
 * Implements of hook_features_rebuild().
 *
 * Rebuilds eck entities from code defaults.
 */
function eck_bundle_features_rebuild($module) {
  if ($default_types = features_get_default('eck_bundle', $module)) {
    foreach ($default_types as $bundle_machine_name => $bundle_info) {
      
      $bundle = new Bundle();
      foreach($bundle_info as $key=>$value){
        $bundle->{$key} = $value;
      }
      $bundle->save();
    }

    drupal_get_schema(NULL, TRUE);
    entity_info_cache_clear();
    menu_rebuild();
  }
}

/**
 * @} End of ECK Bundles
 */
