<?php

/**
 * @file
 * The Flag module.
 *
 * A note on terminology: due to the 7.x-2.x branch of flag being a reasonably
 * straight port of 6.x-2.x, the Drupal 6 term 'content type' persists in
 * function names, database fields, and variables.
 * Thus:
 *  'content type'  -> 'entity type' (though not exclusively, as a flag type
 *                      may be defined for any kind of object)
 *  'content'       -> 'entity'
 *  'sub-type'      -> 'bundle' ('type' is also used sometimes!)
 */

define('FLAG_API_VERSION', 2);

define('FLAG_ADMIN_PATH', 'admin/structure/flags');
define('FLAG_ADMIN_PATH_START', 3);

include_once dirname(__FILE__) . '/flag.inc';

/**
 * Implements hook_menu().
 */
function flag_menu() {
  $items[FLAG_ADMIN_PATH] = array(
    'title' => 'Flags',
    'page callback' => 'flag_admin_page',
    'access callback' => 'user_access',
    'access arguments' => array('administer flags'),
    'description' => 'Configure flags for marking content with arbitrary information (such as <em>offensive</em> or <em>bookmarked</em>).',
    'file' => 'includes/flag.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items[FLAG_ADMIN_PATH . '/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items[FLAG_ADMIN_PATH . '/add'] = array(
    'title' => 'Add a new flag',
    'page callback' => 'flag_add_page',
    'access callback' => 'user_access',
    'access arguments' => array('administer flags'),
    'file' => 'includes/flag.admin.inc',
    'type' => MENU_LOCAL_ACTION,
    'weight' => 1,
  );
  $items[FLAG_ADMIN_PATH . '/import'] = array(
    'title' => 'Import',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('flag_import_form'),
    'access arguments' => array('use flag import'),
    'file' => 'includes/flag.export.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );
  $items[FLAG_ADMIN_PATH . '/export'] = array(
    'title' => 'Export',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('flag_export_form'),
    'access arguments' => array('administer flags'),
    'file' => 'includes/flag.export.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
  );

  $items[FLAG_ADMIN_PATH . '/manage/%flag'] = array(
    'load arguments' => array(TRUE), // Allow for disabled flags.
    'page callback' => 'drupal_get_form',
    'page arguments' => array('flag_form', FLAG_ADMIN_PATH_START + 1),
    'access callback' => 'user_access',
    'access arguments' => array('administer flags'),
    'file' => 'includes/flag.admin.inc',
    'type' => MENU_CALLBACK,
    // Make the flag title the default title for descendant menu items.
    'title callback' => '_flag_menu_title',
    'title arguments' => array(FLAG_ADMIN_PATH_START + 1),
  );
  $items[FLAG_ADMIN_PATH . '/manage/%flag/edit'] = array(
    'load arguments' => array(TRUE), // Allow for disabled flags.
    'title' => 'Edit flag',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items[FLAG_ADMIN_PATH . '/manage/%flag/export'] = array(
    'title' => 'Export',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('flag_export_form', FLAG_ADMIN_PATH_START + 1),
    'access arguments' => array('administer flags'),
    'file' => 'includes/flag.export.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 20,
  );
  $items[FLAG_ADMIN_PATH . '/manage/%flag/delete'] = array(
    'title' => 'Delete flag',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('flag_delete_confirm', FLAG_ADMIN_PATH_START + 1),
    'access callback' => 'user_access',
    'access arguments' => array('administer flags'),
    'file' => 'includes/flag.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items[FLAG_ADMIN_PATH . '/manage/%flag/update'] = array(
    'load arguments' => array(TRUE), // Allow for disabled flags.
    'title' => 'Update',
    'page callback' => 'flag_update_page',
    'page arguments' => array(FLAG_ADMIN_PATH_START + 1),
    'access arguments' => array('administer flags'),
    'file' => 'includes/flag.export.inc',
    'type' => MENU_CALLBACK,
  );

  $items['flag/%/%flag/%'] = array(
    'title' => 'Flag',
    'page callback' => 'flag_page',
    'page arguments' => array(1, 2, 3),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['flag/confirm/%/%flag/%'] = array(
    'title' => 'Flag confirm',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('flag_confirm', 2, 3, 4),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Menu loader for '%flag' arguments.
 *
 * @param $include_disabled
 *   Whether to return a disabled flag too. Normally only enabled flags are
 *   returned. Some menu items operate on disabled flags and in this case
 *   you need to turn on this switch by doing
 *   <code>'load arguments' => array(TRUE)</code> in your menu router.
 *
 * @return
 *   Either the flag object, or FALSE if none was found.
 */
function flag_load($flag_name, $include_disabled = FALSE) {
  if (($flag = flag_get_flag($flag_name))) {
    return $flag;
  }
  else {
    // No enabled flag was found. Search among the disabled ones.
    if ($include_disabled) {
      $default_flags = flag_get_default_flags(TRUE);
      if (isset($default_flags[$flag_name])) {
        return $default_flags[$flag_name];
      }
    }
  }
  // A menu loader has to return FALSE (not NULL) when no object is found.
  return FALSE;
}

/**
 * Menu title callback.
 */
function _flag_menu_title($flag) {
  // The following conditional it to handle a D7 bug (@todo: link).
  return $flag ? $flag->get_title() : '';
}

/**
 * Implements hook_help().
 */
function flag_help($path, $arg) {
  switch ($path) {
    case FLAG_ADMIN_PATH:
      $output = '<p>' . t('This page lists all the <em>flags</em> that are currently defined on this system.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_init().
 */
function flag_init() {
  $path = drupal_get_path('module', 'flag');
  include_once $path . '/includes/flag.actions.inc';
}

/**
 * Implements hook_views_api().
 */
function flag_views_api() {
  return array(
    'api' => 3.0,
    'path' => drupal_get_path('module', 'flag') . '/includes',
  );
}

/**
 * Implements hook_features_api().
 */
function flag_features_api() {
  return array(
    'flag' => array(
      'name' => t('Flag'),
      'feature_source' => TRUE,
      'default_hook' => 'flag_default_flags',
      'file' => drupal_get_path('module', 'flag') . '/includes/flag.features.inc',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function flag_permission() {
  return array(
    'administer flags' => array(
      'title' => t('Administer flags'),
      'description' => t('Create and edit site-wide flags.'),
    ),
    'use flag import' => array(
      'title' => t('Use flag importer'),
      'description' => t('Access the flag import functionality.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_link().
 *
 * This hook does not exist in Drupal 7, it is called from flag_entity_view().
 */
function flag_link($type, $object = NULL, $teaser = FALSE) {
  if (!isset($object) || !flag_fetch_definition($type)) {
    return;
  }
  global $user;

  // Get all possible flags for this content-type.
  $flags = flag_get_flags($type);

  foreach ($flags as $flag) {
    $content_id = $flag->get_content_id($object);

    if (!$flag->uses_hook_link($teaser)) {
      // Flag is not configured to show its link here.
      continue;
    }
    if (!$flag->access($content_id) && (!$flag->is_flagged($content_id) || !$flag->access($content_id, 'flag'))) {
      // User has no permission to use this flag or flag does not apply to this
      // content. The link is not skipped if the user has "flag" access but
      // not "unflag" access (this way the unflag denied message is shown).
      continue;
    }

    // The flag links are actually fully rendered theme functions.
    // The HTML attribute is set to TRUE to allow whatever the themer desires.
    $links['flag-' . $flag->name] = array(
      'title' => $flag->theme($flag->is_flagged($content_id) ? 'unflag' : 'flag', $content_id),
      'html' => TRUE,
    );
  }

  if (isset($links)) {
    return $links;
  }
}

/**
 * Implements hook_flag_link().
 */
function flag_flag_link($flag, $action, $content_id) {
  $token = flag_get_token($content_id);
  return array(
    'href' => 'flag/' . ($flag->link_type == 'confirm' ? 'confirm/' : '') . "$action/$flag->name/$content_id",
    'query' => drupal_get_destination() + ($flag->link_type == 'confirm' ? array() : array('token' => $token)),
  );
}

/**
 * Implements hook_flag_link_types().
 */
function flag_flag_link_types() {
  return array(
    'toggle' => array(
      'title' => t('JavaScript toggle'),
      'description' => t('An AJAX request will be made and degrades to type "Normal link" if JavaScript is not available.'),
      'uses standard js' => TRUE,
      'uses standard css' => TRUE,
    ),
    'normal' => array(
      'title' => t('Normal link'),
      'description' => t('A normal non-JavaScript request will be made and the current page will be reloaded.'),
      'uses standard js' => FALSE,
      'uses standard css' => FALSE,
    ),
    'confirm' => array(
      'title' => t('Confirmation form'),
      'description' => t('The user will be taken to a confirmation form on a separate page to confirm the flag.'),
      'options' => array(
        'flag_confirmation' => '',
        'unflag_confirmation' => '',
      ),
      'uses standard js' => FALSE,
      'uses standard css' => FALSE,
    ),
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function flag_field_extra_fields() {
  $extra = array();

  $flags = flag_get_flags();
  foreach ($flags as $name => $flag) {
    // Skip flags that aren't on entities.
    if (!is_subclass_of($flag, 'flag_entity')) {
      continue;
    }

    // In order to make sense with this hook's structure, we use D7 lingo, hence
    // some translation is required...
    $entity_type = $flag->content_type;
    foreach ($flag->types as $bundle_name) {
      if ($flag->show_on_form) {
        $extra[$entity_type][$bundle_name]['form']['flag'] = array(
          'label' => t('Flags'),
          'description' => t('Checkboxes for toggling flags'),
          'weight' => 10
        );
      }
    }
  }

  return $extra;
}

/**
 * Implements hook_form_FORM_ID_alter(): node_type_form.
 */
function flag_form_node_type_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  $flags = flag_get_flags('node', $form['#node_type']->type, $user);
  foreach ($flags as $flag) {
    if ($flag->show_on_form) {
      $var = 'flag_' . $flag->name . '_default';
      $form['workflow']['flag'][$var] = array(
        '#type' => 'checkbox',
        '#title' => $flag->get_label('flag_short', $form['#node_type']->type),
        '#default_value' => variable_get($var . '_' . $form['#node_type']->type, 0),
        '#return_value' => 1,
      );
    }
  }

  if (isset($form['workflow']['flag'])) {
    $form['workflow']['flag'] += array(
      '#type' => 'item',
      '#title' => t('Default flags'),
      '#description' => t('Above are the <a href="@flag-url">flags</a> you elected to show on the node editing form. You may specify their initial state here.', array('@flag-url' => url(FLAG_ADMIN_PATH))),
      // Make the spacing a bit more compact:
      '#prefix' => '<div class="form-checkboxes">',
      '#suffix' => '</div>',
    );
  }
}

/**
 * Implements hook_field_attach_form().
 *
 * Handles the 'show_on_form' flag option.
 *
 * Warning: will not work on entity types that are not fieldable, as this relies
 * on a field module hook.
 *
 * @see flag_field_attach_submit().
 */
function flag_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  // Nodes have their own special form handling: see flag_form_alter().
  if ($entity_type == 'node') {
    return;
  }

  list($id) = entity_extract_ids($entity_type, $entity);
  // Some modules are being stupid here. Commerce!
  if (empty($id)) {
    $id = NULL;
  }

  // Get all possible flags for this content-type.
  $flags = flag_get_flags($entity_type);

  // Filter out flags which need to be included on the node form.
  $flags_in_form = 0;
  $flags_visible = 0;
  foreach ($flags as $flag) {
    if (!$flag->show_on_form) {
      continue;
    }

    // Get the flag status.
    // We don't have per-bundle defaults on general entities yet.
    $flag_status = $id ? $flag->is_flagged($id) : FALSE;

    // If the flag is not global and the user doesn't have access, skip it.
    // Global flags have their value set even if the user doesn't have access
    // to it, similar to the way "published" and "promote" keep the default
    // values even if the user doesn't have "administer nodes" permission.
    global $user;
    $access = $flag->access($id, $flag_status ? 'unflag' : 'flag');
    if (!$access && !$flag->global) {
      continue;
    }

    $form['flag'][$flag->name] = array(
      '#type' => 'checkbox',
      '#title' => $flag->get_label('flag_short', $id),
      '#description' => $flag->get_label('flag_long', $id),
      '#default_value' => $flag_status,
      '#return_value' => 1,
    );

    // If the user does not have access to the flag, set as a value.
    if (!$access) {
      $form['flag'][$flag->name]['#type'] = 'value';
      $form['flag'][$flag->name]['#value'] = $flag_status;
    }
    else {
      $flags_visible++;
    }
    $flags_in_form++;
  }

  if ($flags_in_form) {
    $form['flag'] += array(
      '#weight' => 1,
      '#tree' => TRUE,
    );
  }
  if ($flags_visible) {
    $form['flag'] += array(
      '#type' => 'fieldset',
      '#title' => t('Flags'),
      '#collapsible' => TRUE,
    );
  }
}

/**
 * Implements hook_field_attach_submit().
 *
 * @see flag_field_attach_form().
 */
function flag_field_attach_submit($entity_type, $entity, $form, &$form_state) {
  // This is invoked for each flag_field_attach_form(), but possibly more than
  // once for a particular form in the case that a form is showing multiple
  // entities (field collection, inline entity form). Hence we can't simply
  // assume our submitted form values are in $form_state['values']['flag'].
  if (isset($form['flag'])) {
    $parents = $form['flag']['#parents'];
    $flag_values = drupal_array_get_nested_value($form_state['values'], $parents);

    // Put the form values in the entity so flag_field_attach_save() can find
    // them. We can't call flag() here as new entities have no id yet.
    $entity->flag = $flag_values;
  }
}

/**
 * Implements hook_field_attach_insert().
 */
function flag_field_attach_insert($entity_type, $entity) {
  if (isset($entity->flag)) {
    flag_field_attach_save($entity_type, $entity);
  }
}

/**
 * Implements hook_field_attach_update().
 */
function flag_field_attach_update($entity_type, $entity) {
  if (isset($entity->flag)) {
    flag_field_attach_save($entity_type, $entity);
  }
}

/**
 * Shared saving routine between flag_field_attach_insert/update().
 *
 * @see flag_field_attach_form().
 */
function flag_field_attach_save($entity_type, $entity) {
  list($id) = entity_extract_ids($entity_type, $entity);
  // Get the flag values we stashed in the entity in flag_field_attach_submit().
  foreach ($entity->flag as $flag_name => $state) {
    flag($state ? 'flag' : 'unflag', $flag_name, $id);
  }
}

/**
 * Implements hook_form_alter().
 */
function flag_form_alter(&$form, &$form_state, $form_id) {
  // Alter node forms.
  if (isset($form['type']) && isset($form['#node']) && ($form_id == $form['type']['#value'] . '_node_form')) {
    global $user;
    $nid = !empty($form['nid']['#value']) ? $form['nid']['#value'] : NULL;
    $flags = flag_get_flags('node', $form['type']['#value'], $user);

    // Filter out flags which need to be included on the node form.
    $flags_in_form = 0;
    $flags_visible = 0;
    foreach ($flags as $name => $flag) {
      if (!$flag->show_on_form) {
        continue;
      }

      if (isset($form['#node']->flag[$flag->name])) {
        $flag_status = $form['#node']->flag[$flag->name];
      }
      else {
        $flag_status_default = variable_get('flag_' . $flag->name . '_default_' . $form['type']['#value'], 0);
        $flag_status = $nid ? $flag->is_flagged($nid) : $flag_status_default;
      }

      // If the flag is not global and the user doesn't have access, skip it.
      // Global flags have their value set even if the user doesn't have access
      // to it, similar to the way "published" and "promote" keep the default
      // values even if the user doesn't have "administer nodes" permission.
      $access = $flag->access($nid, $flag_status ? 'unflag' : 'flag', $user);
      if (!$access && !$flag->global) {
        continue;
      }

      // Add the flag checkbox if displaying on the form.
      $form['flag'][$flag->name] = array(
        '#type' => 'checkbox',
        '#title' => $flag->get_label('flag_short', $nid ? $nid : $form['type']['#value']),
        '#description' => $flag->get_label('flag_long', $nid ? $nid : $form['type']['#value']),
        '#default_value' => $flag_status,
        '#return_value' => 1,
        '#attributes' => array('title' => $flag->get_title()), // Used by our drupalSetSummary().
      );
      // If the user does not have access to the flag, set as a value.
      if (!$access) {
        $form['flag'][$flag->name]['#type'] = 'value';
        $form['flag'][$flag->name]['#value'] = $flag_status;
      }
      else {
        $flags_visible++;
      }
      $flags_in_form++;
    }
    if ($flags_in_form) {
      $form['flag'] += array(
        '#weight' => 1,
        '#tree' => TRUE,
      );
    }
    if ($flags_visible) {
      $form['flag'] += array(
        '#type' => 'fieldset',
        '#title' => t('Flags'),
        '#collapsible' => TRUE,
        // Vertical tabs support:
        '#group' => 'additional_settings',
        '#attributes' => array('class' => array('flag-fieldset')),
        '#attached' => array(
          'js' => array(
            'vertical-tabs' => drupal_get_path('module', 'flag') . '/theme/flag-admin.js',
          ),
        ),
      );
    }

  }
}

/*
 * Implements hook_contextual_links_view_alter().
 */
function flag_contextual_links_view_alter(&$element, $items) {

  // Check if we have a node link to process
  if (isset($element['#element']['#node']->nid)) {
    $node = $element['#element']['#node'];

    // Get all possible flags for this content-type.
    $flags = flag_get_flags('node');

    foreach ($flags as $name => $flag) {
      if (!$flag->show_contextual_link) {
        continue;
      }

      $content_id = $flag->get_content_id($node);
      if (!$flag->access($content_id) && (!$flag->is_flagged($content_id) || !$flag->access($content_id, 'flag'))) {
        // User has no permission to use this flag or flag does not apply to this
        // content. The link is not skipped if the user has "flag" access but
        // not "unflag" access (this way the unflag denied message is shown).
        continue;
      }

      $element['#links']['flag-'. $name] = array(
        'title' => $flag->theme($flag->is_flagged($content_id) ? 'unflag' : 'flag', $content_id),
        'html' => TRUE,
      );
    }
  }
}

/**
 * Implements hook_entity_view().
 *
 * Handles the 'show_on_entity' flag option.
 *
 * Note this is broken for taxonomy terms. @see http://drupal.org/node/1067120
 */
function flag_entity_view($entity, $type, $view_mode, $langcode) {
  $links = flag_link($type, $entity, $view_mode == 'teaser');
  if (isset($links)) {
    $entity->content['links']['flag'] = array(
      '#theme' => 'links',
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }
}

/**
 * Implements hook_node_insert().
 */
function flag_node_insert($node) {
  flag_node_save($node);
}

/**
 * Implements hook_node_update().
 */
function flag_node_update($node) {
  flag_node_save($node);
}

/**
 * Shared saving routine between flag_node_insert() and flag_node_update().
 */
function flag_node_save($node) {
  global $user;

  // Response to the flag checkboxes added to the form in flag_form_alter().
  $remembered = FALSE;
  if (isset($node->flag)) {
    foreach ($node->flag as $name => $state) {
      $flag = flag_get_flag($name);
      // Flagging may trigger actions. We want actions to get the current
      // node, not a stale database-loaded one:
      if (!$remembered) {
        $flag->remember_content($node->nid, $node);
        // Actions may modify a node, and we don't want to overwrite this
        // modification:
        $remembered = TRUE;
      }
      flag($state ? 'flag' : 'unflag', $name, $node->nid, $user);
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function flag_entity_delete($entity, $type) {
  // Node and user flags handle things through the entity type delete hooks.
  // @todo: make this configurable in the flag type definition?
  if ($type == 'node' || $type == 'user') {
    return;
  }

  list($id) = entity_extract_ids($type, $entity);
  _flag_content_delete($type, $id);
}

/**
 * Implements hook_node_delete().
 */
function flag_node_delete($node) {
  foreach (flag_get_flags('node') as $flag) {
    // If the flag is being tracked by translation set and the node is part
    // of a translation set, don't delete the flagging record.
    // Instead, data will be updated in hook_node_translation_change(), below.
    if (!$flag->i18n || empty($node->tnid)) {
      _flag_content_delete('node', $node->nid, $flag->fid);
    }
  }
}

/**
 * Implements hook_node_translation_change().
 *
 * (Hook provided by translation_helpers module.)
 */
function flag_node_translation_change($node) {
  if (isset($node->translation_change)) {
    // If there is only one node remaining, track by nid rather than tnid.
    // Otherwise, use the new tnid.
    $content_id = $node->translation_change['new_tnid'] == 0 ? $node->translation_change['remaining_nid'] : $node->translation_change['new_tnid'];
    foreach (flag_get_flags('node') as $flag) {
      if ($flag->i18n) {
        db_update('flag_content')->fields(array('content_id' => $content_id))
          ->condition('fid', $flag->fid)
          ->condition('content_id', $node->translation_change['old_tnid'])
          ->execute();
        db_update('flag_counts')->fields(array('content_id' => $content_id))
          ->condition('fid', $flag->fid)
          ->condition('content_id', $node->translation_change['old_tnid'])
          ->execute();
      }
    }
  }
}

/**
 * Deletes flagging records for the entity.
 *
 * @param $entity_type
 *   The type of the entity being deleted; e.g. 'node' or 'comment'.
 * @param $entity_id
 *   The ID of the entity being deleted.
 * @param $fid
 *   The flag id
 */
function _flag_content_delete($entity_type, $entity_id, $fid = NULL) {
  $query_content = db_delete('flag_content')
    ->condition('content_type', $entity_type)
    ->condition('content_id', $entity_id);
  $query_counts = db_delete('flag_counts')
    ->condition('content_type', $entity_type)
    ->condition('content_id', $entity_id);
  if (isset($fid)) {
    $query_content->condition('fid', $fid);
    $query_counts->condition('fid', $fid);
  }
  $query_content->execute();
  $query_counts->execute();
}

/**
 * Implements hook_user_login().
 */
function flag_user_login(&$edit, &$account) {
  // Migrate anonymous flags to this user's account.
  if (module_exists('session_api') && ($sid = flag_get_sid(0))) {
    // Get a list of flag_content IDs that will be moved over.
    $duplicate_flaggings = array();
    $flaggings = db_select('flag_content', 'fc')
      ->fields('fc', array('fcid', 'fid', 'content_id'))
      ->condition('uid', 0)
      ->condition('sid', $sid)
      ->execute()
      ->fetchAllAssoc('fcid', PDO::FETCH_ASSOC);

    // Convert anonymous flaggings to their authenticated account.
    foreach ($flaggings as $fcid => $flagging) {
      // Each update is wrapped in a try block to prevent unique key errors.
      // Any duplicate content that was flagged as anonoymous is deleted in the
      // subsequent db_delete() call.
      try {
        db_update('flag_content')
          ->fields(array(
            'uid' => $account->uid,
            'sid' => 0,
          ))
          ->condition('fcid', $fcid)
          ->execute();
      }
      catch (Exception $e) {
        $duplicate_flaggings[$fcid] = $flagging;
      }
    }

    // Delete any remaining flags this user had as an anonymous user. We use the
    // proper unflag action here to make sure the count gets decremented again
    // and so that other modules can clean up their tables if needed.
    $anonymous_user = drupal_anonymous_user();
    foreach ($duplicate_flaggings as $fcid => $flagging) {
      $flag = flag_get_flag(NULL, $flagging['fid']);
      $flag->flag('unflag', $flagging['content_id'], $anonymous_user, TRUE);
    }

    // Clean up anonymous cookies.
    FlagCookieStorage::drop();
  }
}

/**
 * Implements hook_user_cancel().
 */
function flag_user_cancel($edit, $account, $method) {
  flag_user_account_removal($account);
}

/**
 * Implements hook_user_delete().
 */
function flag_user_delete($account) {
  flag_user_account_removal($account);
}

/**
 * Callback function for user account cancellation or deletion.
 */
function flag_user_account_removal($account) {
  // Remove flags by this user.
  $query = db_select('flag_content', 'fc');
  $query->leftJoin('flag_counts', 'c', 'fc.content_id = c.content_id AND fc.content_type = c.content_type');
  $result = $query
    ->fields('fc', array('fid', 'content_id'))
    ->fields('c', array('count'))
    ->condition('fc.uid', $account->uid)
    ->execute();

  foreach ($result as $flag_data) {
    // Only decrement the flag count table if it's greater than 1.
    if ($flag_data->count > 0) {
      $flag_data->count--;
      db_update('flag_counts')
        ->fields(array(
          'count' => $flag_data->count,
        ))
        ->condition('fid', $flag_data->fid)
        ->condition('content_id', $flag_data->content_id)
        ->execute();
    }
    elseif ($flag_data->count == 0) {
      db_delete('flag_counts')
        ->condition('fid', $flag_data->fid)
        ->condition('content_id', $flag_data->content_id)
        ->execute();
    }
  }
  db_delete('flag_content')
    ->condition('uid', $account->uid)
    ->execute();

  // Remove flags that have been done to this user.
  _flag_content_delete('user', $account->uid);
}

/**
 * Implements hook_user_view().
 */
function flag_user_view($account, $view_mode) {
  $flags = flag_get_flags('user');
  $flag_items = array();
  foreach ($flags as $flag) {
    if (!$flag->access($account->uid)) {
      // User has no permission to use this flag.
      continue;
    }
    if (!$flag->uses_hook_link(array())) {
      // Flag not set to appear on profile.
      continue;
    }
    $flag_items[$flag->name] = array(
      '#type' => 'user_profile_item',
      '#title' => $flag->get_title($account->uid),
      '#markup' => $flag->theme($flag->is_flagged($account->uid) ? 'unflag' : 'flag', $account->uid),
      '#attributes' => array('class' => array('flag-profile-' . $flag->name)),
    );
  }
  if (!empty($flag_items)) {
    $account->content['flags'] = $flag_items;
    $account->content['flags'] += array(
      '#type' => 'user_profile_category',
      '#title' => t('Actions'),
      '#attributes' => array('class' => array('flag-profile')),
    );
  }
}

/**
 * Implements hook_session_api_cleanup().
 *
 * Clear out anonymous user flaggings during Session API cleanup.
 */
function flag_session_api_cleanup($arg = 'run') {
  // Session API 1.1 version:
  if ($arg == 'run') {
    $query = db_select('flag_content', 'fc');
    $query->leftJoin('session_api', 's', 'fc.sid = s.sid');
    $result = $query
      ->fields('fc', array('sid'))
      ->condition('fc.sid', 0, '<>')
      ->isNull('s.sid')
      ->execute();
    foreach ($result as $row) {
      db_delete('flag_content')
        ->condition('sid', $row->sid)
        ->execute();
    }
  }
  // Session API 1.2+ version.
  elseif (is_array($arg)) {
    $outdated_sids = $arg;
    db_delete('flag_content')->condition('sid', $outdated_sids, 'IN')->execute();
  }
}

/**
 * Implements hook_field_attach_delete_bundle().
 *
 * Delete any flags' applicability to the deleted bundle.
 */
function flag_field_attach_delete_bundle($entity_type, $bundle, $instances) {
  // This query can't use db_delete() because that doesn't support a
  // subquery: see http://drupal.org/node/1267508.
  db_query("DELETE FROM {flag_types} WHERE type = :bundle AND fid IN (SELECT fid FROM {flags} WHERE content_type = :entity_type)", array(
    ':bundle' => $bundle,
    ':entity_type' => $entity_type,
  ));
}

/**
 * Menu callback for (un)flagging a node.
 *
 * Used both for the regular callback as well as the JS version.
 *
 * @param $action
 *   Either 'flag' or 'unflag'.
 */
function flag_page($action, $flag, $content_id) {
  global $user;

  // Shorten up the variables that affect the behavior of this page.
  $js = isset($_REQUEST['js']);
  $token = $_REQUEST['token'];

  // Specifically $_GET to avoid getting the $_COOKIE variable by the same key.
  $has_js = isset($_GET['has_js']);

  // Check the flag token, then perform the flagging.
  if (!flag_check_token($token, $content_id)) {
    $error = t('Bad token. You seem to have followed an invalid link.');
  }
  elseif ($user->uid == 0 && !$has_js) {
    $error = t('You must have JavaScript and cookies enabled in your browser to flag content.');
  }
  else {
    $result = $flag->flag($action, $content_id);
    if (!$result) {
      $error = t('You are not allowed to flag, or unflag, this content.');
    }
  }

  // If an error was received, set a message and exit.
  if (isset($error)) {
    if ($js) {
      drupal_add_http_header('Content-Type', 'text/javascript; charset=utf-8');
      print drupal_json_encode(array(
        'status' => FALSE,
        'errorMessage' => $error,
      ));
      drupal_exit();
    }
    else {
      drupal_set_message($error);
      drupal_access_denied();
      return;
    }
  }

  // If successful, return data according to the request type.
  if ($js) {
    drupal_add_http_header('Content-Type', 'text/javascript; charset=utf-8');
    $flag->link_type = 'toggle';
    print drupal_json_encode(flag_build_javascript_info($flag, $content_id));
    drupal_exit();
  }
  else {
    drupal_set_message($flag->get_label($action . '_message', $content_id));
    drupal_goto();
  }
}

/**
 * Builds the JavaScript structure describing the flagging operation.
 */
function flag_build_javascript_info($flag, $content_id) {
  $info = array(
    'status' => TRUE,
    'newLink' => $flag->theme($flag->is_flagged($content_id) ? 'unflag' : 'flag', $content_id, TRUE),
    // Further information for the benefit of custom JavaScript event handlers:
    'contentId' => $content_id,
    'contentType' => $flag->content_type,
    'flagName' => $flag->name,
    'flagStatus' => $flag->is_flagged($content_id) ? 'flagged' : 'unflagged',
  );
  drupal_alter('flag_javascript_info', $info);
  return $info;
}

/**
 * Form for confirming the (un)flagging of a piece of content.
 *
 * @param $action
 *   Either 'flag' or 'unflag'.
 * @param $flag
 *   A loaded flag object.
 * @param $content_id
 *   The id of the content to operate on. The type is implicit in the flag.
 *
 * @see flag_confirm_submit()
 */
function flag_confirm($form, &$form_state, $action, $flag, $content_id) {
  $form['action'] = array(
    '#type' => 'value',
    '#value' => $action,
  );
  $form['flag_name'] = array(
    '#type' => 'value',
    '#value' => $flag->name,
  );
  $form['content_id'] = array(
    '#type' => 'value',
    '#value' => $content_id,
  );

  $question = $flag->get_label($action . '_confirmation', $content_id);
  $path = isset($_GET['destination']) ? $_GET['destination'] : '<front>';
  $yes = $flag->get_label($action . '_short', $content_id);

  return confirm_form($form, $question, $path, '', $yes);
}

/**
 * Submit handler for the flag confirm form.
 *
 * Note that validating whether the user may perform the action is done here,
 * rather than in a form validation handler.
 *
 * @see flag_confirm()
 */
function flag_confirm_submit(&$form, &$form_state) {
  $action = $form_state['values']['action'];
  $flag_name = $form_state['values']['flag_name'];
  $content_id = $form_state['values']['content_id'];

  $result = flag($action, $flag_name, $content_id);
  if (!$result) {
    drupal_set_message(t('You are not allowed to flag, or unflag, this content.'));
  }
  else {
    $flag = flag_get_flag($flag_name);
    drupal_set_message($flag->get_label($action . '_message', $content_id));
  }
}

/**
 * Flags or unflags an item.
 *
 * @param $account
 *   The user on whose behalf to flag. Leave empty for the current user.
 * @return
 *   FALSE if some error occured (e.g., user has no permission, flag isn't
 *   applicable to the item, etc.), TRUE otherwise.
 */
function flag($action, $flag_name, $content_id, $account = NULL) {
  if (!($flag = flag_get_flag($flag_name))) {
    // Flag does not exist.
    return FALSE;
  }
  return $flag->flag($action, $content_id, $account);
}

/**
 * Implements hook_flag(). Trigger actions if any are available.
 */
function flag_flag($action, $flag, $content_id, $account) {
  if (module_exists('trigger')) {
    $context['hook'] = 'flag';
    $context['account'] = $account;
    $context['flag'] = $flag;
    $context['op'] = $action;
    // We add to the $context all the objects we know about:
    $context = array_merge($flag->get_relevant_action_objects($content_id), $context);
    // The primary object the actions work on.
    $object = $flag->fetch_content($content_id);

    // Generic "all flags" actions.
    foreach (trigger_get_assigned_actions('flag_' . $action)  as $aid => $action_info) {
      // The 'if ($aid)' is a safeguard against http://drupal.org/node/271460#comment-886564
      if ($aid) {
        actions_do($aid, $object, $context);
      }
    }
    // Actions specifically for this flag.
    foreach (trigger_get_assigned_actions('flag_' . $action . '_' . $flag->name) as $aid => $action_info) {
      if ($aid) {
        actions_do($aid, $object, $context);
      }
    }
  }

  if (module_exists('rules')) {
    $event_name = ($action == 'flag' ? 'flag_flagged_' : 'flag_unflagged_') . $flag->name;
    // We only support flags on entities.
    if (entity_get_info($flag->content_type)) {
      $variables = array(
        'flag' => $flag,
        'flagged_' . $flag->content_type => $content_id,
        'flagging_user' => $account,
      );
      rules_invoke_event_by_args($event_name, $variables);
    }
  }
}

/**
 * Implements hook_flag_access().
 */
function flag_flag_access($flag, $content_id, $action, $account) {
  // Do nothing if there is no restriction by authorship.
  if (empty($flag->access_author)) {
    return;
  }

  // Restrict access by authorship. It's important that TRUE is never returned
  // here, otherwise we'd grant permission even if other modules denied access.
  if ($flag->content_type == 'node') {
    // For non-existent nodes (such as on the node add form), assume that the
    // current user is creating the content.
    if (empty($content_id) || !($node = node_load($content_id))) {
      return $flag->access_author == 'others' ? FALSE : NULL;
    }

    if ($flag->access_author == 'own' && $node->uid != $account->uid) {
      return FALSE;
    }
    elseif ($flag->access_author == 'others' && $node->uid == $account->uid) {
      return FALSE;
    }
  }

  // Restrict access by comment authorship.
  if ($flag->content_type == 'comment') {
    // For non-existent comments (such as on the comment add form), assume that
    // the current user is creating the content.
    if (empty($content_id) || !($comment = $flag->fetch_content($content_id))) {
      return $flag->access_author == 'comment_others' ? FALSE : NULL;
    }

    $node = node_load($comment->nid);
    if ($flag->access_author == 'node_own' && $node->uid != $account->uid) {
      return FALSE;
    }
    elseif ($flag->access_author == 'node_others' && $node->uid == $account->uid) {
      return FALSE;
    }
    elseif ($flag->access_author == 'comment_own' && $comment->uid != $account->uid) {
      return FALSE;
    }
    elseif ($flag->access_author == 'comment_others' && $comment->uid == $account->uid) {
      return FALSE;
    }
  }
}

/**
 * Implements hook_flag_access_multiple().
 */
function flag_flag_access_multiple($flag, $content_ids, $account) {
  $access = array();

  // Do nothing if there is no restriction by authorship.
  if (empty($flag->access_author)) {
    return $access;
  }

  if ($flag->content_type == 'node') {
    // Restrict access by authorship. This is similar to flag_flag_access()
    // above, but returns an array of 'nid' => $access values. Similarly, we
    // should never return TRUE in any of these access values, only FALSE if we
    // want to deny access, or use the current access value provided by Flag.
    $result = db_select('node', 'n')
      ->fields('n', array('nid', 'uid'))
      ->condition('nid', array_keys($content_ids), 'IN')
      ->condition('type', $flag->types, 'IN')
      ->execute();
    foreach ($result as $row) {
      if ($flag->access_author == 'own') {
        $access[$row->nid] = $row->uid != $account->uid ? FALSE : NULL;
      }
      elseif ($flag->access_author == 'others') {
        $access[$row->nid] = $row->uid == $account->uid ? FALSE : NULL;
      }
    }
  }

  if ($flag->content_type == 'comment') {
    // Restrict access by comment ownership.
    $query = db_select('comment', 'c');
    $query->leftJoin('node', 'n', 'c.nid = n.nid');
    $query
      ->fields('c', array('cid', 'nid', 'uid'))
      ->condition('c.cid', $content_ids, 'IN');
    $query->addField('c', 'uid', 'comment_uid');
    $result = $query->execute();

    foreach ($result as $row) {
      if ($flag->access_author == 'node_own') {
        $access[$row->cid] = $row->node_uid != $account->uid ? FALSE : NULL;
      }
      elseif ($flag->access_author == 'node_others') {
        $access[$row->cid] = $row->node_uid == $account->uid ? FALSE : NULL;
      }
      elseif ($flag->access_author == 'comment_own') {
        $access[$row->cid] = $row->comment_uid != $account->uid ? FALSE : NULL;
      }
      elseif ($flag->access_author == 'comment_others') {
        $access[$row->cid] = $row->comment_uid == $account->uid ? FALSE : NULL;
      }
    }
  }

  // Always return an array (even if empty) of accesses.
  return $access;
}

/**
 * Trim a flag to a certain size.
 *
 * @param $fid
 *   The flag object.
 * @param $account
 *   The user object on behalf the trimming will occur.
 * @param $cutoff_size
 *   The number of flaggings allowed. Any flaggings beyond that will be trimmed.
 */
function flag_trim_flag($flag, $account, $cutoff_size) {
  $result = db_select('flag_content', 'fc')
    ->fields('fc')
    ->condition('fid', $flag->fid)
    ->condition(db_or()->condition('uid', $account->uid)->condition('uid', 0))
    ->orderBy('timestamp', 'DESC')
    ->execute();
  $i = 1;
  foreach ($result as $row) {
    if ($i++ > $cutoff_size) {
      flag('unflag', $flag->name, $row->content_id, $account);
    }
  }
}

/**
 * Remove all flagged content from a flag.
 *
 * @param $flag
 *   The flag object.
 * @param $content_id
 *   Optional. The content ID on which all flaggings will be removed. If left
 *   empty, this will remove all of this flag's content.
 */
function flag_reset_flag($flag, $content_id = NULL) {
  $query = db_select('flag_content', 'fc')
    ->fields('fc')
    ->condition('fid', $flag->fid);

  if ($content_id) {
    $query->condition('content_id', $content_id);
  }

  $result = $query->execute()->fetchAllAssoc('fcid', PDO::FETCH_ASSOC);
  $rows = array();
  foreach ($result as $row) {
    $rows[] = $row;
  }
  module_invoke_all('flag_reset', $flag, $content_id, $rows);

  $query = db_delete('flag_content')->condition('fid' , $flag->fid);
  // Update the flag_counts table.
  $count_query = db_delete('flag_counts')->condition('fid', $flag->fid);
  if ($content_id) {
    $query->condition('content_id', $content_id);
    $count_query->condition('content_id', $content_id);
  }
  $count_query->execute();
  return $query->execute();
}

/**
 * Implements hook_node_operations().
 *
 * Add additional options on the admin/build/node page.
 */
function flag_node_operations() {
  global $user;

  $flags = flag_get_flags('node', NULL, $user);
  $operations = array();

  foreach ($flags as $flag) {
    $operations['flag_' . $flag->name] = array(
      'label' => $flag->get_label('flag_short'),
      'callback' => 'flag_nodes',
      'callback arguments' => array('flag', $flag->name),
      'behavior' => array(),
    );
    $operations['unflag_' . $flag->name] = array(
      'label' => $flag->get_label('unflag_short'),
      'callback' => 'flag_nodes',
      'callback arguments' => array('unflag', $flag->name),
      'behavior' => array(),
    );
  }
  return $operations;
}

/**
 * Callback function for hook_node_operations().
 */
function flag_nodes($nodes, $action, $flag_name) {
  $performed = FALSE;
  foreach ($nodes as $nid) {
    $performed |= flag($action, $flag_name, $nid);
  }
  if ($performed) {
    drupal_set_message(t('The update has been performed.'));
  }
}

/**
 * Implements hook_user_operations().
 */
function flag_user_operations() {
  global $user;

  $flags = flag_get_flags('user', NULL, $user);
  $operations = array();

  foreach ($flags as $flag) {
    $operations['flag_' . $flag->name] = array(
      'label' => $flag->get_label('flag_short'),
      'callback' => 'flag_users',
      'callback arguments' => array('flag', $flag->name),
    );
    $operations['unflag_' . $flag->name] = array(
      'label' => $flag->get_label('unflag_short'),
      'callback' => 'flag_users',
      'callback arguments' => array('unflag', $flag->name),
    );
  }
  return $operations;
}
/**
 * Callback function for hook_user_operations().
 */
function flag_users($users, $action, $flag_name) {
  foreach ($users as $uid) {
    flag($action, $flag_name, $uid);
  }
}

/**
 * Implements hook_mail().
 */
function flag_mail($key, &$message, $params) {
  switch ($key) {
    case 'over_threshold':
      $message['subject'] = $params['subject'];
      $message['body'] = $params['body'];
      break;
  }
}

/**
 * Implements hook_theme().
 */
function flag_theme() {
  $path = drupal_get_path('module', 'flag') . '/theme';

  return array(
    'flag' => array(
      'variables' => array('flag' => NULL, 'action' => NULL, 'content_id' => NULL, 'after_flagging' => FALSE),
      'template' => 'flag',
      'pattern' => 'flag__',
      'path' => $path,
    ),
    'flag_tokens_browser' => array(
      'variables' => array('types' => array('all'), 'global_types' => TRUE),
      'file' => 'flag.tokens.inc',
    ),
    'flag_admin_listing' => array(
      'render element' => 'form',
      'file' => 'includes/flag.admin.inc',
    ),
    'flag_admin_listing_disabled' => array(
      'variables' => array('flags' => NULL, 'default_flags' => NULL),
      'file' => 'includes/flag.admin.inc',
    ),
    'flag_admin_page' => array(
      'variables' => array('flags' => NULL, 'default_flags' => NULL, 'flag_admin_listing' => NULL),
      'file' => 'includes/flag.admin.inc',
    ),
    'flag_form_roles' => array(
      'render element' => 'element',
      'file' => 'includes/flag.admin.inc',
    ),
  );
}

/**
 * A preprocess function for our theme('flag'). It generates the
 * variables needed there.
 *
 * The $variables array initially contains the following arguments:
 * - $flag
 * - $action
 * - $content_id
 * - $after_flagging
 *
 * See 'flag.tpl.php' for their documentation.
 */
function template_preprocess_flag(&$variables) {
  global $user;
  $initialized = &drupal_static(__FUNCTION__, array());

  // Some typing shotcuts:
  $flag =& $variables['flag'];
  $action = $variables['action'];
  $content_id = $variables['content_id'];
  $flag_css_name = str_replace('_', '-', $flag->name);

  // Generate the link URL.
  $link_type = $flag->get_link_type();
  $link = module_invoke($link_type['module'], 'flag_link', $flag, $action, $content_id);
  if (isset($link['title']) && empty($link['html'])) {
    $link['title'] = check_plain($link['title']);
  }

  // Replace the link with the access denied text if unable to flag.
  if ($action == 'unflag' && !$flag->access($content_id, 'unflag')) {
    $link['title'] = $flag->get_label('unflag_denied_text', $content_id);
    unset($link['href']);
  }

  // Anonymous users always need the JavaScript to maintain their flag state.
  if ($user->uid == 0) {
    $link_type['uses standard js'] = TRUE;
  }

  // Load the JavaScript/CSS, if the link type requires it.
  if (!isset($initialized[$link_type['name']])) {
    if ($link_type['uses standard css']) {
      drupal_add_css(drupal_get_path('module', 'flag') . '/theme/flag.css');
    }
    if ($link_type['uses standard js']) {
      drupal_add_js(drupal_get_path('module', 'flag') . '/theme/flag.js');
    }
    $initialized[$link_type['name']] = TRUE;
  }

  $variables['link'] = $link;
  $variables['link_href'] = isset($link['href']) ? check_url(url($link['href'], $link)) : FALSE;
  $variables['link_text'] = isset($link['title']) ? $link['title'] : $flag->get_label($action . '_short', $content_id);
  $variables['link_title'] = isset($link['attributes']['title']) ? check_plain($link['attributes']['title']) : check_plain(strip_tags($flag->get_label($action . '_long', $content_id)));
  $variables['status'] = ($action == 'flag' ? 'unflagged' : 'flagged');
  $variables['flag_name_css'] = $flag_css_name;

  $variables['flag_wrapper_classes_array'] = array();
  $variables['flag_wrapper_classes_array'][] = 'flag-wrapper';
  $variables['flag_wrapper_classes_array'][] = 'flag-' . $flag_css_name;
  $variables['flag_wrapper_classes_array'][] = 'flag-' . $flag_css_name . '-' . $content_id;
  $variables['flag_wrapper_classes'] = implode(' ', $variables['flag_wrapper_classes_array']);

  $variables['flag_classes_array'] = array();
  $variables['flag_classes_array'][] = 'flag';
  $variables['flag_classes_array'][] = $variables['action'] . '-action';
  $variables['flag_classes_array'][] = 'flag-link-' . $flag->link_type;
  if (isset($link['attributes']['class'])) {
    $link['attributes']['class'] = is_string($link['attributes']['class']) ? array_filter(explode(' ', $link['attributes']['class'])) : $link['attributes']['class'];
    $variables['flag_classes_array'] = array_merge($variables['flag_classes_array'], $link['attributes']['class']);
  }
  if ($variables['after_flagging']) {
    $inverse_action = ($action == 'flag' ? 'unflag' : 'flag');
    $variables['message_text'] = $flag->get_label($inverse_action . '_message', $content_id);
    $variables['flag_classes_array'][] = $variables['status'];
  }
  $variables['flag_classes'] = implode(' ', $variables['flag_classes_array']);

  // Backward compatibility: The following section preserves some deprecated
  // variables either to make old flag.tpl.php files continue to work, or to
  // prevent PHP from generating E_NOTICEs there. @todo: Remove these sometime.
  $variables['setup'] = FALSE;
  $variables['last_action'] = $variables['status'];
}

/**
 * Return an array of flag names keyed by fid.
 */
function _flag_get_flag_names() {
  $flags = flag_get_flags();
  $flag_names = array();
  foreach ($flags as $flag) {
    $flag_names[$flag->fid] = $flag->name;
  }
  return $flag_names;
}

/**
 * Return an array of flag link types suitable for a select list or radios.
 */
function _flag_link_type_options() {
  $options = array();
  $types = flag_get_link_types();
  foreach ($types as $type_name => $type) {
    $options[$type_name] = $type['title'];
  }
  return $options;
}

/**
 * Return an array of flag link type descriptions.
 */
function _flag_link_type_descriptions() {
  $options = array();
  $types = flag_get_link_types();
  foreach ($types as $type_name => $type) {
    $options[$type_name] = $type['description'];
  }
  return $options;
}

/**
 * Return an array of flag link fields that are dependent on a link type.
 */
function _flag_link_type_fields() {
  $options = array();
  $types = flag_get_link_types();
  foreach ($types as $type_name => $type) {
    $options[$type_name] = array_keys($type['options']);
  }
  return $options;
}

// ---------------------------------------------------------------------------
// Non-Views public API

/**
 * Get flag counts for all flags on a node.
 *
 * @param $content_type
 *   The content type (usually 'node').
 * @param $content_id
 *   The content ID (usually the node ID).
 * @param $reset
 *   Reset the internal cache and execute the SQL query another time.
 *
 * @return $flags
 *   An array of the structure [name] => [number of flags].
 */
function flag_get_counts($content_type, $content_id, $reset = FALSE) {
  $counts = &drupal_static(__FUNCTION__);

  if ($reset) {
    $counts = array();
    if (!isset($content_type)) {
      return;
    }
  }

  if (!isset($counts[$content_type][$content_id])) {
    $counts[$content_type][$content_id] = array();
    $query = db_select('flags', 'f');
    $query->leftJoin('flag_counts', 'fc', 'f.fid = fc.fid');
    $result = $query
      ->fields('f', array('name'))
      ->fields('fc', array('count'))
      ->condition('fc.content_type', $content_type)
      ->condition('fc.content_id', $content_id)
      ->execute();
    foreach ($result as $row) {
      $counts[$content_type][$content_id][$row->name] = $row->count;
    }
  }

  return $counts[$content_type][$content_id];
}

/**
 * Get the total count of items flagged within a flag.
 *
 * @param $flag_name
 *   The flag name for which to retrieve a flag count.
 * @param $reset
 *   Reset the internal cache and execute the SQL query another time.
 */
function flag_get_flag_counts($flag_name, $reset = FALSE) {
  $counts = &drupal_static(__FUNCTION__);

  if ($reset) {
    $counts = array();
  }
  if (!isset($counts[$flag_name])) {
    $flag = flag_get_flag($flag_name);
    $counts[$flag_name] = db_select('flag_counts', 'fc')->fields('fc', array('fcid'))
      ->condition('fid', $flag->fid)->countQuery()->execute()->fetchField();
  }

  return $counts[$flag_name];
}

/**
 * Load a single flag either by name or by flag ID.
 *
 * @param $name
 *  (optional) The flag name.
 * @param $fid
 *  (optional) The the flag id.
 *
 * @return
 *  The flag object, or FALSE if no matching flag was found.
 */
function flag_get_flag($name = NULL, $fid = NULL) {
  $flags = flag_get_flags();
  if (isset($name)) {
    if (isset($flags[$name])) {
      return $flags[$name];
    }
  }
  elseif (isset($fid)) {
    foreach ($flags as $flag) {
      if ($flag->fid == $fid) {
        return $flag;
      }
    }
  }
  return FALSE;
}

/**
 * List all flags available.
 *
 * If node type or account are entered, a list of all possible flags will be
 * returned.
 *
 * @param $content_type
 *   Optional. The type of content for which to load the flags. Usually 'node'.
 * @param $content_subtype
 *   Optional. The node type for which to load the flags.
 * @param $account
 *   Optional. The user accont to filter available flags. If not set, all
 *   flags for will this node will be returned.
 * @param $reset
 *   Optional. Reset the internal query cache.
 *
 * @return $flags
 *   An array of the structure [fid] = flag_object.
 */
function flag_get_flags($content_type = NULL, $content_subtype = NULL, $account = NULL, $reset = FALSE) {
  $flags = &drupal_static(__FUNCTION__);

  // Retrieve a list of all flags, regardless of the parameters.
  if (!isset($flags) || $reset) {
    $flags = array();

    // Database flags.
    $query = db_select('flags', 'f');
    $query->leftJoin('flag_types', 'fn', 'fn.fid = f.fid');
    $result = $query
      ->fields('f', array('fid', 'content_type', 'name', 'title', 'global', 'options'))
      ->fields('fn', array('type'))
      ->execute();
    foreach ($result as $row) {
      if (!isset($flags[$row->name])) {
        $flags[$row->name] = flag_flag::factory_by_row($row);
      }
      else {
        $flags[$row->name]->types[] = $row->type;
      }
    }

    // Add code-based flags provided by modules.
    $default_flags = flag_get_default_flags();
    foreach ($default_flags as $name => $default_flag) {
      // Insert new enabled flags into the database to give them an FID.
      if ($default_flag->status && !isset($flags[$name])) {
        $default_flag->save();
        $flags[$name] = $default_flag;
      }

      if (isset($flags[$name])) {
        // Ensure overridden flags are associated with their parent module.
        $flags[$name]->module = $default_flag->module;

        // Update the flag with any properties that are "locked" by the code version.
        if (isset($default_flag->locked)) {
          $flags[$name]->locked = $default_flag->locked;
          foreach ($default_flag->locked as $property) {
            $flags[$name]->$property = $default_flag->$property;
          }
        }
      }
    }

    // Sort the list of flags by weight.
    uasort($flags, '_flag_compare_weight');

    // Allow modules implementing hook_flag_alter(&$flag) to modify each flag.
    foreach ($flags as $flag) {
      drupal_alter('flag', $flag);
    }
  }

  // Make a variable copy to filter types and account.
  $filtered_flags = $flags;

  // Filter out flags based on type and subtype.
  if (isset($content_type) || isset($content_subtype)) {
    foreach ($filtered_flags as $name => $flag) {
      if (!_flag_content_enabled($flag, $content_type, $content_subtype)) {
        unset($filtered_flags[$name]);
      }
    }
  }

  // Filter out flags based on account permissions.
  if (isset($account) && $account->uid != 1) {
    foreach ($filtered_flags as $name => $flag) {
      // We test against the 'flag' action, which is the minimum permission to
      // use a flag.
      if (!$flag->user_access('flag', $account)) {
        unset($filtered_flags[$name]);
      }
    }
  }

  return $filtered_flags;
}

/**
 * Comparison function for uasort().
 */
function _flag_compare_weight($flag1, $flag2) {
  if ($flag1->weight == $flag2->weight) {
    return 0;
  }
  return $flag1->weight < $flag2->weight ? -1 : 1;
}

/**
 * Utility function: Checks whether a flag applies to a certain type, and
 * possibly subtype, of content.
 *
 * @param $content_type
 *   The type of content being checked, usually "node".
 * @param $content_subtype
 *   The subtype (node type) being checked.
 *
 * @return
 *   TRUE if the flag is enabled for this type and subtype.
 */
function _flag_content_enabled($flag, $content_type, $content_subtype = NULL) {
  $return = $flag->content_type == $content_type && (!isset($content_subtype) || in_array($content_subtype, $flag->types));
  return $return;
}

/**
 * Retrieve a list of flags defined by modules.
 *
 * @param $include_disabled
 *   Unless specified, only enabled flags will be returned.
 * @return
 *   An array of flag prototypes, not usable for flagging. Use flag_get_flags()
 *   if needing to perform a flagging with any enabled flag.
 */
function flag_get_default_flags($include_disabled = FALSE) {
  $default_flags = array();
  $flag_status = variable_get('flag_default_flag_status', array());

  foreach (module_implements('flag_default_flags') as $module) {
    $function = $module . '_flag_default_flags';
    foreach ($function() as $flag_name => $flag_info) {
      // Backward compatibility: old exported default flags have their names
      // in $flag_info instead, so we use the += operator to not overwrite it.
      $flag_info += array(
        'name' => $flag_name,
        'module' => $module,
      );
      $flag = flag_flag::factory_by_array($flag_info);

      // Disable flags that are not at the current API version.
      if (!$flag->is_compatible()) {
        $flag->status = FALSE;
      }

      // Add flags that have been enabled.
      if ((!isset($flag_status[$flag->name]) && (!isset($flag->status) || $flag->status)) || !empty($flag_status[$flag->name])) {
        $flag->status = TRUE;
        $default_flags[$flag->name] = $flag;
      }
      // Add flags that have been disabled.
      elseif ($include_disabled) {
        $flag->status = FALSE;
        $default_flags[$flag->name] = $flag;
      }
    }
  }

  return $default_flags;
}

/**
 * Get all flagged content in a flag.
 *
 * @param
 *   The flag name for which to retrieve flagged content.
 */
function flag_get_flagged_content($flag_name) {
  $return = array();
  $flag = flag_get_flag($flag_name);
  $result = db_select('flag_content', 'fc')
    ->fields('fc')
    ->condition('fid', $flag->fid)
    ->execute();
  foreach ($result as $row) {
    $return[] = $row;
  }
  return $return;
}

/**
 * Get content ID from a flag content ID.
 *
 * @param $fcid
 *   The flag content ID for which to look up the content ID.
 */
function flag_get_content_id($fcid) {
  return db_select('flag_content', 'fc')
    ->fields('fc', array('content_id'))
    ->condition('fcid', $fcid)
    ->execute()
    ->fetchField();
}

/**
 * Find what a user has flagged, either a single node or on the entire site.
 *
 * @param $content_type
 *   The type of content that will be retrieved. Usually 'node'.
 * @param $content_id
 *   Optional. The content ID to check for flagging. If none given, all
 *   content flagged by this user will be returned.
 * @param $uid
 *   Optional. The user ID whose flags we're checking. If none given, the
 *   current user will be used.
 * @param $sid
 *   Optional. The user SID (provided by Session API) whose flags we're
 *   checking. If none given, the current user will be used. The SID is 0 for
 *   logged in users.
 * @param $reset
 *   Reset the internal cache and execute the SQL query another time.
 *
 * @return $flags
 *   If returning a single item's flags (that is, when $content_id isn't NULL),
 *   an array of the structure
 *   [flag_name] => (fcid => [fcid], uid => [uid], content_id => [content_id], timestamp => [timestamp], ...)
 *
 *   If returning all items' flags, an array of arrays for each flag:
 *   [flag_name] => [content_id] => Object from above.
 *
 */
function flag_get_user_flags($content_type, $content_id = NULL, $uid = NULL, $sid = NULL, $reset = FALSE) {
  $flagged_content = &drupal_static(__FUNCTION__);

  if ($reset) {
    $flagged_content = array();
    if (!isset($content_type)) {
      return;
    }
  }

  $uid = !isset($uid) ? $GLOBALS['user']->uid : $uid;
  $sid = !isset($sid) ? flag_get_sid($uid) : $sid;

  if (isset($content_id)) {
    if (!isset($flagged_content[$uid][$sid][$content_type][$content_id])) {
      $flag_names = _flag_get_flag_names();
      $flagged_content[$uid][$sid][$content_type][$content_id] = array();
      $result = db_select('flag_content', 'fc')
        ->fields('fc')
        ->condition('content_type', $content_type)
        ->condition('content_id', $content_id)
        ->condition(db_or()
          ->condition('uid', $uid)
          ->condition('uid', 0)
        )
        ->condition('sid', $sid)
        ->execute();

      foreach ($result as $flag_content) {
        $flagged_content[$uid][$sid][$content_type][$content_id][$flag_names[$flag_content->fid]] = $flag_content;
      }
    }
    return $flagged_content[$uid][$sid][$content_type][$content_id];
  }

  else {
    if (!isset($flagged_content[$uid][$sid][$content_type]['all'])) {
      $flag_names = _flag_get_flag_names();
      $flagged_content[$uid][$sid][$content_type]['all'] = array();
      $result = db_select('flag_content', 'fc')
        ->fields('fc')
        ->condition('content_type', $content_type)
        ->condition(db_or()
          ->condition('uid', $uid)
          ->condition('uid', 0)
        )
        ->condition('sid', $sid)
        ->execute();
      foreach ($result as $flag_content) {
        $flagged_content[$uid][$sid][$content_type]['all'][$flag_names[$flag_content->fid]][$flag_content->content_id] = $flag_content;
      }
    }
    return $flagged_content[$uid][$sid][$content_type]['all'];
  }

}

/**
 * Return a list of users who have flagged a piece of content.
 *
 * @param $content_type
 *   The type of content that will be retrieved. Usually 'node'.
 * @param $content_id
 *   The content ID to check for flagging.
 * @param $flag_name
 *   Optional. The name of a flag if wanting a list specific to a single flag.
 *
 * @return
 *   If no flag name is given, an array of flagged content, keyed by the user
 *   ID that flagged the content. Each flagged content array is structured as
 *   an array of flag information for each flag, keyed by the flag name. If
 *   a flag name is specified, only the information for that flag is returned.
 */
function flag_get_content_flags($content_type, $content_id, $flag_name = NULL) {
  $content_flags = &drupal_static(__FUNCTION__, array());

  if (!isset($content_flags[$content_type][$content_id])) {
    $flag_names = _flag_get_flag_names();
    $result = db_select('flag_content', 'fc')
      ->fields('fc')
      ->condition('content_type', $content_type)
      ->condition('content_id', $content_id)
      ->orderBy('timestamp', 'DESC')
      ->execute();
    foreach ($result as $flag_content) {
      // Build a list of flaggings for all flags by user.
      $content_flags[$content_type][$content_id]['users'][$flag_content->uid][$flag_names[$flag_content->fid]] = $flag_content;
      // Build a list of flaggings for each individual flag.
      $content_flags[$content_type][$content_id]['flags'][$flag_names[$flag_content->fid]][$flag_content->uid] = $flag_content;
    }
  }

  return isset($flag_name) ? $content_flags[$content_type][$content_id]['flags'][$flag_name] : $content_flags[$content_type][$content_id]['users'];
}

/**
 * A utility function for outputting a flag link.
 *
 * You should call this function from your template when you want to put the
 * link on the page yourself. For example, you could call this function from
 * your 'node.tpl.php':
 *
 *   <?php print flag_create_link('bookmarks', $node->nid); ?>
 *
 * @param $flag_name
 *   The "machine readable" name of the flag; e.g. 'bookmarks'.
 * @param $content_id
 *   The content ID to check for flagging. This is usually a node ID.
 */
function flag_create_link($flag_name, $content_id) {
  $flag = flag_get_flag($flag_name);
  if (!$flag) {
    // Flag does not exist.
    return;
  }
  if (!$flag->access($content_id) && (!$flag->is_flagged($content_id) || !$flag->access($content_id, 'flag'))) {
    // User has no permission to use this flag.
    return;
  }
  return $flag->theme($flag->is_flagged($content_id) ? 'unflag' : 'flag', $content_id);
}

/**
 * Return an array of link types provided by modules.
 *
 * @param $reset
 *  (Optional) Whether to reset the static cache.
 *
 * @return
 *  An array of link types as defined by hook_flag_link_types(). These are keyed
 *  by the type name, and each value is an array of properties. In addition to
 *  those defined in hook_flag_link_types(), the following properties are set:
 *  - 'module': The providing module.
 *  - 'name': The machine name of the type.
 *
 * @see hook_flag_link_types()
 * @see hook_flag_link_types_alter()
 */
function flag_get_link_types($reset = FALSE) {
  $link_types = &drupal_static(__FUNCTION__);

  if (!isset($link_types) || $reset) {
    $link_types = array();
    foreach (module_implements('flag_link_types') as $module) {
      $module_types = module_invoke($module, 'flag_link_types');
      foreach ($module_types as $type_name => $info) {
        $link_types[$type_name] = $info + array(
          'module' => $module,
          'name' => $type_name,
          'title' => '',
          'description' => '',
          'options' => array(),
          'uses standard js' => TRUE,
          'uses standard css' => TRUE,
        );
      }
    }
    drupal_alter('flag_link_types', $link_types);
  }

  return $link_types;
}

/**
 * Get a private token used to protect links from spoofing - CSRF.
 */
function flag_get_token($content_id) {
  // Anonymous users get a less secure token, since it must be the same for all
  // anonymous users on the entire site to work with page caching.
  return ($GLOBALS['user']->uid) ? drupal_get_token($content_id) : md5(drupal_get_private_key() . $content_id);
}

/**
 * Check to see if a token value matches the specified node.
 */
function flag_check_token($token, $content_id) {
  return flag_get_token($content_id) == $token;
}

/**
 * Set the Session ID for a user. Utilizes the Session API module.
 */
function flag_set_sid($uid = NULL, $create = TRUE) {
  $sids = &drupal_static(__FUNCTION__, array());

  if (!isset($uid)) {
    $uid = $GLOBALS['user']->uid;
  }

  if (!isset($sids[$uid])) {
    if (module_exists('session_api') && session_api_available() && $uid == 0) {
      $sids[$uid] = session_api_get_sid($create);
    }
    else {
      $sids[$uid] = 0;
    }
  }

  return $sids[$uid];
}

/**
 * Get the Session ID for a user. Utilizes the Session API module.
 *
 * @param $uid
 *   The user ID. If the UID is 0 (anonymous users), then a SID will be
 *   returned. SID will always be 0 for any authenticated user.
 * @param $create
 *   If the user doesn't yet have a session, should one be created? Defaults
 *   to FALSE.
 */
function flag_get_sid($uid = NULL, $create = FALSE) {
  return flag_set_sid($uid, $create);
}
